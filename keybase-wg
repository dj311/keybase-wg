#!/usr/bin/env python3

header = \
"""

        __              __
       / /_____  __  __/ /_  ____ _________       _      ______ _
      / //_/ _ \/ / / / __ \/ __ `/ ___/ _ \ ___ | | /| / / __ `/
     / ,< /  __/ /_/ / /_/ / /_/ (__  /  __/.___`| |/ |/ / /_/ /
    /_/|_|\___/\__, /_.___/\__,_/____/\___/      |__/|__/\__, /
              /____/                                    /____/

"""

description = \
"""
Quickly setup virtual private networks for Keybase teams with Wireguard.
"""

dev_docs = \
"""
Internal Network Structure:

We use the local network section of the IPv6 address space (fc00::/7). The specification
requires the next 40-bits to be a randomly generated. We don't quite do this, but it's
close. We take the first 40-bits of the hashed team name. The rest uniquely represents
the (user, device) pair. Splitting the team should allow for simpler routing between
interfaces on clients.

In summary:
  [0-8]  0xfd
  [8-48] sha256(team_name + "keybase-wg")[0:40]
  [48-88] sha256(user_name)[0:40]
  [88-128] sha256(device_name)[0:84]

This means the internal network layout is directly determined from the current team
membership. Adding or removing new members doesn't have any affect on existing IPs.

In the future, I want to make use of this to have nice hostnames like
"<device>.<user>.<team>.keybase.local". With the design above, this can be done via a
little stateless DNS server that runs on each users machine.

This is easy to achieve if Avahi is already setup and running. Then run:
  $ avahi-publish-address \
      <device_name>.<user_name>.<team_name>.local \
      <generate_device_ip(team_name, user_name, device_name)>

"""

__doc__ = header + description + dev_docs


import argparse
import hashlib
import json
import os
import subprocess
import shlex
import ipaddress
import requests


KEEP_ALIVE = 25


def sha256(x):
    return hashlib.sha256(bytes(x, encoding='utf-8')).digest()


def generate_team_subnet(team_name):
    local_network_prefix = bytes.fromhex("fd")
    # avoid collisions with unrelated applications that have hashed this team name as a
    # subnet by concating "keybase-wg" to input
    team_subnet = sha256(team_name + "keybase-wg")[0:5]
    return local_network_prefix + team_subnet


def generate_user_subnet(team_name, user_name):
    team_subnet = generate_team_subnet(team_name)
    user_subnet = sha256(user_name)[0:5]
    return team_subnet + user_subnet


def generate_device_ip(team_name, user_name, device_name):
    user_subnet = generate_user_subnet(team_name, user_name)
    device_subnet = sha256(device_name)[0:5]
    return user_subnet + device_subnet


def make_ipv6_cidr(ip):
    len_bytes = len(ip)

    if len_bytes < 16:  # subnet
        padded_subnet = ip + bytes((16-len_bytes)*[0])
        prefix_length = len_bytes * 8
        return str(ipaddress.IPv6Network(
            (padded_subnet, prefix_length)
        ))

    else:  # full_address
        return str(ipaddress.IPv6Address(ip))


def get_team_members(team_name):
    command = {
        "method": "list-team-memberships",
        "params": {
            "options": {
                "team": team_name
            }
        }
    }
    command = json.dumps(command)
    response = run_command(
        "Fetching team info",
        ["keybase", "team", "api"],
        stdin=command,
    )
    response = json.loads(response)

    members = response['result']['members']['owners'] + \
        response['result']['members']['admins'] + \
        response['result']['members']['writers'] + \
        response['result']['members']['readers']

    members = [
        {
            'name': member['username'],
            'id': member['uv']['uid'],
        }
        for member in members
    ]

    return members


def get_device_info():
    response = run_command(
        "Getting your info",
        ["keybase", "status", "--json"],
    )
    response = json.loads(response)
    return {
        'user': response['Username'],
        'user_id': response['UserID'],
        'device': response['Device']['name'],
        'device_id': response['Device']['deviceID'],
    }


def generate_config(team_name, user_name, device_name):
    my_ip = generate_device_ip(team_name, user_name, device_name)

    config_file = (
        "[Interface]\n",
        "PrivateKey = {private_key}\n",
        "ListenPort = {listen_port}\n",
        "\n",
    )

    team_members = get_team_members(team_name)
    for member in team_members:
        subnet = generate_user_subnet(team_name, member)
        config_file += (
            f"[Peer]\n",
            f"PublicKey = {public_key}\n",
            f"AllowedIPs = {subnet}\n",
            f"PersistentKeepalive = {KEEP_ALIVE}\n",
            f"\n",
        )


def run_command(desc, command, stdin=None):
    command_preview = " ".join([shlex.quote(part) for part in command])

    print(f"\n{desc}:")
    print(f"  $ {command_preview}")

    result = subprocess.run(
        command,
        input=stdin,
        stdout=subprocess.PIPE,
        check=True,
        encoding='utf-8',
    ).stdout

    print("")

    return result



if __name__ == "__main__":
    print(header)

    parser = argparse.ArgumentParser(description=description)
    subparsers = parser.add_subparsers(dest='action')

    up_parser = subparsers.add_parser('up', help='connect to a network')
    up_parser.add_argument('--team', help='name of team to connect with', required=True)
    up_parser.add_argument('--interface', help='network interface to use', required=True)

    refresh_parser = subparsers.add_parser('refresh', help='check team state and regenerate config (if needed)')
    refresh_operand = refresh_parser.add_mutually_exclusive_group(required=True)
    refresh_operand.add_argument('--team', help='identify network by team name')
    refresh_operand.add_argument('--interface', help='identify network by interface name')

    status_parser = subparsers.add_parser('status', help='check network status')
    status_operand = status_parser.add_mutually_exclusive_group(required=True)
    status_operand.add_argument('--team', help='identify network by team name')
    status_operand.add_argument('--interface', help='identify network by interface name')

    down_parser = subparsers.add_parser('down', help='disconnect from a network')
    down_operand = down_parser.add_mutually_exclusive_group(required=True)
    down_operand.add_argument('--team', help='identify network by team name')
    down_operand.add_argument('--interface', help='identify network by interface name')

    args = parser.parse_args()

    me = get_device_info()
    print("me \t", me)
    print("team members \t", get_team_members("djwj_dev_team"))
    print("device ip \t", make_ipv6_cidr(generate_device_ip("djwj_dev_team", "djwj", "wildebeest")))
    print("user subnet \t", make_ipv6_cidr(generate_user_subnet("djwj_dev_team", "djwj")))
    print("team subnet \t", make_ipv6_cidr(generate_team_subnet("djwj_dev_team")))

    if args.action == 'up':
        # 1. Generate public and private wireguard keys for the
        #    given (device_id, user_id, team_id) combination
        # 2. Get this clients IP address for the network.
        # 3. Generate public and private wireguard keys for
        #    given (device_id, user_id, team_id) combination
        pass

    elif args.action == 'refresh':
        pass

    elif args.action == 'status':
        pass

    elif args.action == 'down':
        pass
