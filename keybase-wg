#!/usr/bin/env python3

header = """

        __              __
       / /_____  __  __/ /_  ____ _________       _      ______ _
      / //_/ _ \/ / / / __ \/ __ `/ ___/ _ \ ___ | | /| / / __ `/
     / ,< /  __/ /_/ / /_/ / /_/ (__  /  __/.___`| |/ |/ / /_/ /
    /_/|_|\___/\__, /_.___/\__,_/____/\___/      |__/|__/\__, /
              /____/                                    /____/

"""

description = """
Quickly setup virtual private networks for Keybase teams with Wireguard.
"""

dev_docs = """
TODO:
  - Finish script by saving conf file and running "wg-quick".
  - Sanitize inputs by parsing them as the things they should
    be. Double check places where we stick stuff in the command line.
  - Double check that the team name given is valid.
  - Where possible, double check that say peer with device_id=x is
    actually in our team. Which leads to....
  - Figure out a way to invalid devices which have been revoked.
    - I think the way to do this is to check which key was used to
      sign each value in the keystore. Was it the current team key? Or
      was it the old one? If it was an old one, reject it.
    - This might be an alternative method:
      $ echo '{"method": "getdeviceinfo", "params": {"options": {"username": "?"}}}' \
        | keybase chat api -p
      {"result": {
          "devices": [
              {
                  "id": "<device_id>",
                  "description": "<device_name>",
                  "type": "<type>",
                  "ctime": <creation_time>
              }
          ]
    }}
  - Test with multiple devices.
  - Use UDP ports properly.
  - Sort out hole-punching.
  - Use second public IP address API and compare results.


Internal Network Structure:

We use the local network section of the IPv6 address space (fc00::/7). The specification
requires the next 40-bits to be a randomly generated. We don't quite do this, but it's
close. We take the first 40-bits of the hashed team name. The rest uniquely represents
the (user, device) pair. Splitting the team should allow for simpler routing between
interfaces on clients.

In summary:
  [0-8]  0xfd
  [8-48] sha256(team_name + "keybase-wg")[0:40]
  [48-88] sha256(user_name)[0:40]
  [88-128] sha256(device_name)[0:84]

This means the internal network layout is directly determined from the current team
membership. Adding or removing new members doesn't have any affect on existing IPs.

In the future, I want to make use of this to have nice hostnames like
"<device>.<user>.<team>.keybase.local". With the design above, this can be done via a
little stateless DNS server that runs on each users machine.

This is easy to achieve if Avahi is already setup and running. Then run:
  $ avahi-publish-address \
      <device_name>.<user_name>.<team_name>.local \
      <generate_device_ip(team_name, user_name, device_name)>

"""

__doc__ = header + description + dev_docs


import asyncio
import argparse
import hashlib
import json
import os
import subprocess
import shlex
import ipaddress
import requests
import pykeybasebot
import time


KEEP_ALIVE = 25
LISTEN_PORT = "51820"


def sha256(x):
    return hashlib.sha256(bytes(x, encoding="utf-8")).digest()


def generate_team_subnet(team_name):
    local_network_prefix = bytes.fromhex("fd")
    # avoid collisions with unrelated applications that have hashed this team name as a
    # subnet by concating "keybase-wg" to input
    team_subnet = sha256(team_name + "keybase-wg")[0:5]
    return local_network_prefix + team_subnet


def generate_user_subnet(team_name, user_name):
    team_subnet = generate_team_subnet(team_name)
    user_subnet = sha256(user_name)[0:5]
    return team_subnet + user_subnet


def generate_device_ip(team_name, user_name, device_name):
    user_subnet = generate_user_subnet(team_name, user_name)
    device_subnet = sha256(device_name)[0:5]
    return user_subnet + device_subnet


def make_ipv6_cidr(ip):
    len_bytes = len(ip)

    if len_bytes < 16:  # subnet
        padded_subnet = ip + bytes((16 - len_bytes) * [0])
        prefix_length = len_bytes * 8
        return str(ipaddress.IPv6Network((padded_subnet, prefix_length)))

    else:  # full_address
        return str(ipaddress.IPv6Address(ip))


def get_team_members(team_name):
    command = {
        "method": "list-team-memberships",
        "params": {"options": {"team": team_name}},
    }
    command = json.dumps(command)
    response = run_command(
        "Fetching team info", ["keybase", "team", "api"], stdin=command,
    )
    response = json.loads(response)

    members = (
        response["result"]["members"]["owners"]
        + response["result"]["members"]["admins"]
        + response["result"]["members"]["writers"]
        + response["result"]["members"]["readers"]
    )

    members = [
        {"name": member["username"], "id": member["uv"]["uid"],} for member in members
    ]

    return members


def get_device_info():
    response = run_command("Getting your info", ["keybase", "status", "--json"],)
    response = json.loads(response)
    return {
        "user": response["Username"],
        "user_id": response["UserID"],
        "device": response["Device"]["name"],
        "device_id": response["Device"]["deviceID"],
    }


def generate_config(private_key, internal_ip, peers):
    config = (
        f"[Interface]\n"
        f"PrivateKey = {private_key}\n"
        f"Address = {internal_ip}\n"
        f"ListenPort = {LISTEN_PORT}\n"
        f"\n"
    )

    for peer_key, peer in peers.items():
        config += (
            f"[Peer]\n"
            f"PublicKey = {peer['public_key']}\n"
            f"AllowedIPs = {peer['internal_ip']}\n"
            f"Endpoint = {peer['external_ip']}:{LISTEN_PORT}\n"
            f"PersistentKeepalive = {KEEP_ALIVE}\n"
            f"\n"
        )

    return config


def generate_keypair():
    private_key = run_command("Generating private key", ["wg", "genkey"]).strip()

    public_key = run_command(
        "Deriving public key", ["wg", "pubkey"], stdin=private_key
    ).strip()

    return private_key, public_key


def fetch_network_state(bot):
    keys = asyncio.run(bot.kvstore.list_entrykeys("keybase-wg", team=args.team))

    keys = keys.entry_keys
    keys = [key.entry_key for key in keys]
    keys = set(keys)

    config_keys = {key for key in keys if key.endswith("-config")}

    peers = {
        key: json.loads(
            asyncio.run(bot.kvstore.get("keybase-wg", key, args.team)).entry_value
        )
        for key in config_keys
    }

    return peers


def generate_interface_name(team):
    return f"kb-{team}"[0:15]


def generate_hostname(team, user, device):
    return f"{device}.{user}.{team}.local"


def run_command(desc, command, stdin=None):
    command_preview = " ".join([shlex.quote(part) for part in command])

    print(f"\n{desc}:")
    print(f"  $ {command_preview}")

    result = subprocess.run(
        command, input=stdin, stdout=subprocess.PIPE, check=True, encoding="utf-8",
    ).stdout

    return result


if __name__ == "__main__":
    print(header)

    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("--team", help="name of team to connect with", required=True)

    args = parser.parse_args()

    # The "bot" is our interface to keybase
    def event_handler(*args, **kwargs):
        pass

    bot = pykeybasebot.Bot(handler=event_handler)

    print("\n► Fetching/generating device information.")
    me = get_device_info()

    private_key, public_key = generate_keypair()
    print("")
    print("private key \t", private_key)
    print("public key \t", public_key)

    # Figure out my public ip
    # TODO: I feel like there is a more "correct way" of doing this.
    external_ip = requests.get("https://checkip.amazonaws.com").text.strip()
    print("external ip \t", external_ip)

    # Generate my internal ip
    internal_ip = make_ipv6_cidr(
        generate_device_ip(args.team, me["user"], me["device"])
    )
    print("internal ip \t", internal_ip)

    # Publish my details for others
    print("\n► Publishing my device information to team.")
    asyncio.run(
        bot.kvstore.put(
            "keybase-wg",
            me["device_id"] + "-config",
            json.dumps(
                {
                    "device_id": me["device_id"],
                    "public_key": public_key,
                    "internal_ip": internal_ip,
                    "external_ip": external_ip,
                }
            ),
            team=args.team,
        )
    )

    print("\n► Fetching team information.")
    peers = fetch_network_state(bot)

    # Remove ourselves from the peer list
    peers = {
        key: peer for key, peer in peers.items() if peer["device_id"] != me["device_id"]
    }

    print("\n► Configuring device.")
    interface = generate_interface_name(args.team)
    config_str = generate_config(private_key, internal_ip, peers)

    interface_conf_path = "./" + interface + ".conf"
    with open(interface_conf_path, "w") as f:
        f.writelines(config_str)

    run_command(
        "Join the network", ["wg-quick", "up", interface_conf_path],
    )

    # Use avahi to setup nice hostnames
    # internal_name = generate_hostname(args.team, me["user"], me["device"])
    # run_command(
    #     "Giving our device a name on the team network",
    #     ["avahi-publish-address", internal_name, internal_ip],
    # )

    print("\n► Listening for changes in network config...")
    try:
        while True:
            time.sleep(10)

            new_peers = fetch_network_state(bot)
            new_peers = {
                key: peer
                for key, peer in new_peers.items()
                if peer["device_id"] != me["device_id"]
            }

            peers_changed = [
                peers.get(key) != new_peers.get(key) for key in new_peers.keys()
            ]
            peer_added = any([key not in peers for key in new_peers])
            peer_removed = any([key not in new_peers for key in peers])

            if peer_added or peer_removed or any(peers_changed):
                print("Change detected: syncing configuration with team.")
                peers = new_peers

                run_command(
                    "Taking interface down", ["wg-quick", "down", interface_conf_path],
                )

                config_str = generate_config(private_key, internal_ip, peers)
                with open(interface_conf_path, "w") as f:
                    f.writelines(config_str)

                run_command(
                    "Putting interface up", ["wg-quick", "up", interface_conf_path],
                )

    except (KeyboardInterrupt, SystemExit):
        print("► Disconnecting from network.")

        run_command(
            "Taking interface down", ["wg-quick", "down", interface_conf_path],
        )
        run_command(
            "Deleting wireguard config", ["rm", interface_conf_path],
        )

        print("Deregistering from network.\n")
        asyncio.run(
            bot.kvstore.delete(
                "keybase-wg", me["device_id"] + "-config", team=args.team,
            )
        )

        print("Bye!")
        quit()
