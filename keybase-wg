#!/usr/bin/env python3

header = """

        __              __
       / /_____  __  __/ /_  ____ _________       _      ______ _
      / //_/ _ \/ / / / __ \/ __ `/ ___/ _ \ ___ | | /| / / __ `/
     / ,< /  __/ /_/ / /_/ / /_/ (__  /  __/.___`| |/ |/ / /_/ /
    /_/|_|\___/\__, /_.___/\__,_/____/\___/      |__/|__/\__, /
              /____/                                    /____/

"""

description = """
Quickly setup virtual private networks for Keybase teams with Wireguard.
"""

dev_docs = """
Internal Network Structure:

We use the local network section of the IPv6 address space (fc00::/7). The specification
requires the next 40-bits to be a randomly generated. We don't quite do this, but it's
close. We take the first 40-bits of the hashed team name. The rest uniquely represents
the (user, device) pair. Splitting the team should allow for simpler routing between
interfaces on clients.

In summary:
  [0-8]  0xfd
  [8-48] sha256(team_name + "keybase-wg")[0:40]
  [48-88] sha256(user_name)[0:40]
  [88-128] sha256(device_name)[0:84]

This means the internal network layout is directly determined from the current team
membership. Adding or removing new members doesn't have any affect on existing IPs.

In the future, I want to make use of this to have nice hostnames like
"<device>.<user>.<team>.keybase.local". With the design above, this can be done via a
little stateless DNS server that runs on each users machine.

This is easy to achieve if Avahi is already setup and running. Then run:
  $ avahi-publish-address \
      <device_name>.<user_name>.<team_name>.local \
      <generate_device_ip(team_name, user_name, device_name)>

"""

__doc__ = header + description + dev_docs


import asyncio
import argparse
import hashlib
import json
import os
import subprocess
import shlex
import ipaddress
import requests
import pykeybasebot


KEEP_ALIVE = 25
LISTEN_PORT = "51820"


def sha256(x):
    return hashlib.sha256(bytes(x, encoding="utf-8")).digest()


def generate_team_subnet(team_name):
    local_network_prefix = bytes.fromhex("fd")
    # avoid collisions with unrelated applications that have hashed this team name as a
    # subnet by concating "keybase-wg" to input
    team_subnet = sha256(team_name + "keybase-wg")[0:5]
    return local_network_prefix + team_subnet


def generate_user_subnet(team_name, user_name):
    team_subnet = generate_team_subnet(team_name)
    user_subnet = sha256(user_name)[0:5]
    return team_subnet + user_subnet


def generate_device_ip(team_name, user_name, device_name):
    user_subnet = generate_user_subnet(team_name, user_name)
    device_subnet = sha256(device_name)[0:5]
    return user_subnet + device_subnet


def make_ipv6_cidr(ip):
    len_bytes = len(ip)

    if len_bytes < 16:  # subnet
        padded_subnet = ip + bytes((16 - len_bytes) * [0])
        prefix_length = len_bytes * 8
        return str(ipaddress.IPv6Network((padded_subnet, prefix_length)))

    else:  # full_address
        return str(ipaddress.IPv6Address(ip))


def get_team_members(team_name):
    command = {
        "method": "list-team-memberships",
        "params": {"options": {"team": team_name}},
    }
    command = json.dumps(command)
    response = run_command(
        "Fetching team info", ["keybase", "team", "api"], stdin=command,
    )
    response = json.loads(response)

    members = (
        response["result"]["members"]["owners"]
        + response["result"]["members"]["admins"]
        + response["result"]["members"]["writers"]
        + response["result"]["members"]["readers"]
    )

    members = [
        {"name": member["username"], "id": member["uv"]["uid"],} for member in members
    ]

    return members


def get_device_info():
    response = run_command("Getting your info", ["keybase", "status", "--json"],)
    response = json.loads(response)
    return {
        "user": response["Username"],
        "user_id": response["UserID"],
        "device": response["Device"]["name"],
        "device_id": response["Device"]["deviceID"],
    }


def generate_config(private_key, internal_ip, peers):
    config = (
        f"[Interface]\n"
        f"PrivateKey = {private_key}\n"
        f"Address = {internal_ip}\n"
        f"ListenPort = {LISTEN_PORT}\n"
        f"\n"
    )

    for peer in peers:
        config += (
            f"[Peer]\n"
            f"PublicKey = {peer['public_key']}\n"
            f"AllowedIPs = {peer['internal_ip']}\n"
            f"Endpoint = {peer['external_ip']}:{LISTEN_PORT}\n"
            f"PersistentKeepalive = {KEEP_ALIVE}\n"
            f"\n"
        )

    return config


def run_command(desc, command, stdin=None):
    command_preview = " ".join([shlex.quote(part) for part in command])

    print(f"\n{desc}:")
    print(f"  $ {command_preview}")

    result = subprocess.run(
        command, input=stdin, stdout=subprocess.PIPE, check=True, encoding="utf-8",
    ).stdout

    print("")

    return result


if __name__ == "__main__":
    print(header)

    parser = argparse.ArgumentParser(description=description)
    subparsers = parser.add_subparsers(dest="action")

    up_parser = subparsers.add_parser("up", help="connect to a network")
    up_parser.add_argument("--team", help="name of team to connect with", required=True)
    up_parser.add_argument(
        "--interface", help="network interface to use", required=True
    )

    refresh_parser = subparsers.add_parser(
        "refresh", help="check team state and regenerate config (if needed)"
    )
    refresh_operand = refresh_parser.add_mutually_exclusive_group(required=True)
    refresh_operand.add_argument("--team", help="identify network by team name")
    refresh_operand.add_argument(
        "--interface", help="identify network by interface name"
    )

    status_parser = subparsers.add_parser("status", help="check network status")
    status_operand = status_parser.add_mutually_exclusive_group(required=True)
    status_operand.add_argument("--team", help="identify network by team name")
    status_operand.add_argument(
        "--interface", help="identify network by interface name"
    )

    down_parser = subparsers.add_parser("down", help="disconnect from a network")
    down_operand = down_parser.add_mutually_exclusive_group(required=True)
    down_operand.add_argument("--team", help="identify network by team name")
    down_operand.add_argument("--interface", help="identify network by interface name")

    args = parser.parse_args()

    me = get_device_info()
    print("me \t", me)
    print("team members \t", get_team_members("djwj_dev_team"))
    print(
        "device ip \t",
        make_ipv6_cidr(generate_device_ip("djwj_dev_team", "djwj", "wildebeest")),
    )
    print(
        "user subnet \t", make_ipv6_cidr(generate_user_subnet("djwj_dev_team", "djwj"))
    )
    print("team subnet \t", make_ipv6_cidr(generate_team_subnet("djwj_dev_team")))

    # 1. Generate public and private wireguard keys for the
    #    given (device_id, user_id, team_id) combination
    # 2. Get this clients IP address for the network.
    # 3. Generate public and private wireguard keys for
    #    given (device_id, user_id, team_id) combination

    # Generate my new keys
    private_key = run_command("Generating private key", ["wg", "genkey"]).strip()
    print("private key \t", private_key)

    public_key = run_command(
        "Deriving public key", ["wg", "pubkey"], stdin=private_key
    ).strip()
    print("public key \t", public_key)

    # Figure out my public ip
    # TODO: I feel like there is a more "correct way" of doing
    # this.
    external_ip = requests.get("https://checkip.amazonaws.com").text.strip()
    print("external ip \t", external_ip)

    # Generate my internal ip
    internal_ip = make_ipv6_cidr(
        generate_device_ip(args.team, me["user"], me["device"])
    )
    print("internal ip \t", internal_ip)

    # Publish my details for others
    def event_handler(*args, **kwargs):
        pass

    bot = pykeybasebot.Bot(handler=event_handler)
    asyncio.run(
        bot.kvstore.put(
            "keybase-wg",
            me["device_id"] + "-config",
            json.dumps(
                {
                    "device_id": me["device_id"],
                    "public_key": public_key,
                    "internal_ip": internal_ip,
                    "external_ip": external_ip,
                }
            ),
            team=args.team,
        )
    )

    # Pull in latest details from team members
    store_entry_keys = asyncio.run(
        bot.kvstore.list_entrykeys("keybase-wg", team=args.team)
    )
    config_entry_keys = {
        entry_key.entry_key
        for entry_key in store_entry_keys.entry_keys
        if entry_key.entry_key.endswith("-config")
    }
    peers = [
        json.loads(
            asyncio.run(bot.kvstore.get("keybase-wg", entry_key, args.team)).entry_value
        )
        for entry_key in config_entry_keys
    ]

    peers = [peer for peer in peers if peer["device_id"] != me["device_id"]]

    # Want to only ensure valid devices are allowed. The following
    # doesn't work because it's per-user.
    # allowed_team_members = [member["id"] for member in get_team_members(args.team)]
    # peers = [peer for peer in peers if peer in allowed_team_members]

    # Generate config
    config_str = generate_config(private_key, internal_ip, peers)
    print(config_str)

    # wg-quick up
